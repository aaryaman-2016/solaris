#include<iostream>

using namespace std;

int m, n;
int row[4] = {-1, 1, 0, 0};
int col[4] = {0, 0, -1, 1};

bool inside (int r, int c)
{
    return (0 <= r && r < m && 0<= c && c < n);
}
int mymin(int a, int b){return (a < b) ? a : b;}

char **A = 0;
int **id = 0;
int *disc = 0, *low = 0, *par = 0;
char *isCut = 0;
int *wr = 0, *wc = 0;
int tim = 0;

int count_islands(void)
{
    int **vis = new int*[m];
    for (int i = 0; i <m; i++)
    {
        vis[i] = new int[n];
        for(int j = 0; j < n; j++) vis[i][j] = 0;
    }

    int cap = m * n; 
    int *qr = new int[cap];
    int *qc = new int[cap];

    int count = 0; 
    for(int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (A[i][j] == '1' && !vis[i][j])
            {
                count++;
                int head = 0, tail = 0;
                qr[tail] = i;
                qc[tail] = j;
                tail++;
                vis[i][j] = 1;

                while(head < tail)
                {
                    int r = qr[head];
                    int c = qc[head];
                    head++;
                    for (int d = 0; d < 4; d++)
                    {
                        int nr = r + row[d];
                        int nc = c + col[d];
                        if (inside(nr,nc)&& A[nr][nc] == '1' && !vis[nr][nc])
                        {
                            vis[nr][nc] = 1;
                            qr[tail] = nr; 
                            qc[tail] = nc;
                            tail++;
                        }
                    }
                }
            }
        }
    }

    for(int i = 0; i < m; i++) delete[] vis[i];
    delete[] vis;
    delete[] qr;
    delete[] qc;

    return count;
}

void dfs(int r, int c, int v)
{
    disc[v] = low [v] = ++tim;
    int childcount = 0;

    for (int d = 0; d < 4; d++)
    {
        int nr = r + row[d];
        int nc = c + col[d];
        if(!inside(nr,nc)) continue;
        int to = id[nr][nc];
        if (to == -1) continue;
        if(disc[to] == -1)
        {
            par[to] = v; childcount++;
            dfs(nr, nc, to);
            low[v] = mymin(low[v], low[to]);
            if(par[v] != 1 && low[to] >= disc[v]) isCut[v] = 1;
        }
        else if(to != par[v])
        {
            low[v] = mymin(low[v], disc[to]);
        }
    }


    if(par[v] == -1 && childcount >= 2) isCut[v] = 1; //if root is an articulation point
}

int main(void)
{
    cin >> m >> n;
    A = new char*[m];
    for (int i = 0; i < m; i++)
    {
        A[i] = new char[n];
    }

    for (int i = 0; i < m; i ++)
    {
        for (int j = 0; j < n; j++)
        {
            int x;
            cin >> x;
            A[i][j] = (x ? '1': '0');
        }
    }

    int islands = count_islands();
    if(islands == 0 || islands >= 2)
    {
        cout << 0 << "\n";
    }

    int V = 0;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if(A[i][j] == '1') V++;
        }
    }

    if (V<=2)
    {
        cout << V << "\n";
    }

    id = new int*[m];
    for (int i = 0; i < m; i++)
    {
        id[i] = new int[n];
        for(int j = 0; j < n; j++) id[i][j] = -1;
    }

    wr = new int[V];
    wc = new int[V];

    int s = -1, sr = 0, sc = 0, cur = 0;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if(A[i][j] == '1')
            {
                id[i][j] = cur;
                wr[cur] = i;
                wc[cur] = j;
                if (s == -1){s = cur; sr = i; sc = j;}
                cur++;
            }
        }
    }

    disc = new int[V];
    low  = new int[V];
    par = new int[V];
    isCut = new char[V];

    for(int i=0;i<V;i++){
        disc[i] = -1;
        low[i] = -1;
        par[i] = -1;
        isCut[i] = 0;
    }
    tim = 0;

    // Run DFS from any land cell (the island is connected)
    dfs(sr, sc, s);

    for(int v=0; v<V; v++)
    {
        if(isCut[v]){
            cout << 1 << "\n";
            return 0;
        }
    }

    cout << 2 << "\n";
    return 0;
}